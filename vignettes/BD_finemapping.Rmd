---
title: "Bipolar Disorder: fine-mapping" 
author: "<h4>Author: <i>Brian M. Schilder</i></h4>" 
date: "<h4>Updated: <i>`r format( Sys.Date(), '%b-%d-%Y')`</i></h4>"
output:
  BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{BD_finemapping} 
    %\usepackage[utf8]{inputenc}
    %\VignetteEngine{knitr::rmarkdown}
---


```{r setup}
#### Install echolocatoR >= v2.0 ####
if(!require("echolocatoR")){
  remotes::install_github("RajLabMSSM/echolocatoR@echoverse", 
                          upgrade = TRUE, dependencies = TRUE)    
} else if (packageVersion("echolocatoR")<"2.0.0"){
  remotes::install_github("RajLabMSSM/echolocatoR@echoverse",
                          upgrade = TRUE, dependencies = TRUE)
}
library(echolocatoR) 

### Set to wherever you want to store your data 
save_dir <- "~/Desktop"
```

### [Optional] Docker

`echolocatoR` doesn't yet have it's own Docker container, 
but in the meantime you can use the official `MAGMA.Celltyping` Docker container which includes an Rstudio interface (see [vignette here](https://neurogenomics.github.io/MAGMA_Celltyping/articles/docker)).  

Then, simply install `echolocatoR` from within the container 
using the same instructions as above.

 
## Prepare `top_SNPs` data.frame   

Import the data.frame of containing lead/proxy SNPs to indicate where each GWAS locus is. 
 
```{r  Prepare `top_SNPs` data.frame}  
top_SNPs <- echodata::import_topSNPs(topSS = file.path(save_dir,
                                                       "my_loci.xlsx"))
head(top_SNPs)
```

## Path to full summary stats file  
 
To prepare the data for use with `echolocatoR` 
(without the need for manual column mapping) we must first munge the sumstats.

```{r fullSS}  
#### Set up paths ####
fullSS_path_vcf <- file.path(save_dir,"pgc-bip2021-all.vcf.tsv.gz"  )
target_path <- echotabix::construct_tabix_path(gsub(".vcf","",fullSS_path_vcf))
#### Look at the header of the pre-munged file ####
# MungeSumstats:::read_header(fullSS_path_vcf, n=3)
# header <- MungeSumstats::read_sumstats(fullSS_path_vcf, 
#                                        nrows = 100, 
#                                        standardise_headers = FALSE)
# header

#### Download file #####
if(!file.exists(fullSS_path_vcf)){
  utils::download.file("https://figshare.com/ndownloader/files/26603681",
                       fullSS_path_vcf)
}
#### Munge ####
if(!file.exists(target_path)){ 
  ## [Option 1]: MungeSumstats::format_sumstats
  ## Run the complete munging pipeline with additional QC
  ## Run with tabix_index=TRUE to index as well
  ## Correct the NGT column in the mapping file.
  ## Otherwise, NGT will be incorrectly be interpreted as N.
  # mapping_file <- subset(MungeSumstats:::sumstatsColHeaders,
  #                        Uncorrected!="NGT")
  # mss_out <- MungeSumstats::format_sumstats(path = fullSS_path_vcf,
  #                                           save_path = target_path,
  #                                           sort_coordinates = TRUE,
  #                                           log_folder = "~/Downloads/munge_logs",
  #                                           log_mungesumstats_msgs = TRUE,
  #                                           log_folder_ind = TRUE,
  #                                           tabix_index = TRUE,
  #                                           mapping_file = mapping_file)
  # target_path <- mss_out$sumstats
  
  ## [Option 2] MungeSumstats::write_sumstats
  ## Run just the column header mapping and write back to disk 
  
  ## Correct the NGT column in the mapping file.
  ## Otherwise, NGT will be incorrectly be interpreted as N.
  mapping_file <- subset(MungeSumstats:::sumstatsColHeaders,
                         Uncorrected!="NGT")
  dat <- MungeSumstats::read_sumstats(path = fullSS_path_vcf, 
                                      standardise_headers = TRUE, 
                                      mapping_file = mapping_file)
  #### Add N column (necessary for most fine-mapping methods) ####
  dat[,N:=(NCAS+NCON)]
  #### Add "proportion_cases" column (needed for ABF) ####
  dat[,proportion_cases:=(NCAS/(NCAS+NCON))]
  target_path <- MungeSumstats::write_sumstats(sumstats_dt = dat,
                                               save_path = target_path,
                                               tabix_index = TRUE,
                                               return_path = TRUE)  
  
  ## [Option 3]: echotabix::convert
  ### If you don't want to read the data into memory, 
  ## you can alternatively convert it with echotabix::convert
  ## Takes about the same amount of time as MungeSumstats::write_sumstats method
  # tabix_files <- echotabix::convert(fullSS_path = fullSS_path_munged, 
  #                                   start_col = "BP")
  # target_path <- tabix_files$path
  
  #### Free up memory in R by removing the full data ####
  remove(dat)
} else {
  message("Using pre-existing file: ",target_path)
} 
```

## Query subset

```{r}
loci <- top_SNPs$Locus
#### Select one locus ####
top_SNPs_locus <- top_SNPs[loci[1],]

#### Construct a query to extract a single locus ####
window_size <- 1000000/2
query_granges <- echotabix::construct_query(
  query_chrom = top_SNPs_locus$CHR, 
  query_start_pos = top_SNPs_locus$POS - window_size, 
  query_end_pos = top_SNPs_locus$POS + window_size)

#### Extract subset #####
dat_locus <- echotabix::query(target_path = target_path, 
                              query_granges = query_granges) 
### Preview the data ####
echodata::createDT(head(dat_locus))
```

## Get LD

`echoLD::get_LD` uses the coordinates from you locus-specific data to retrieve a subset of whole-sequencing sequencing data from the 1000 Genomes Project (in VCF format).

It then computes pairwise linkage disequilibrium (LD) between all SNPs in that 
subset.

```{r}
locus_dir <- file.path(save_dir, top_SNPs_locus$Locus) 

LD_list  <- echoLD::get_LD(query_dat = dat_locus,
                           locus_dir = locus_dir,
                           superpopulation = "EUR",
                           LD_reference = "1KGphase3", 
                           force_new_LD = TRUE) 
```

## Fine-map

We can now run fine-mapping on the locus subset. You'll notice the the output
is the same `dat` object that was fed in, but with some new columns containing 
the results from each fine-mapping method that was run.

```{r}
dat2 <- echofinemap::multifinemap(dat = LD_list$DT,
                                  locus_dir = locus_dir,  
                                  LD_matrix = LD_list$LD, 
                                  finemap_methods=c("ABF","SUSIE","FINEMAP"),
                                  n_causal = 2,
                                  force_new_finemap = TRUE)
knitr::kable(head(dat2))
```

## Plot locus results

```{r}
if(!require("pals")) install.packages("pals")

#### We'll need this column to color SNPs by LD with the lead SNP ####
dat2 <- echodata::assign_lead_snp(dat = dat2)

plot_list <- echoplot::plot_locus(dat = dat2, 
                                  LD_matrix = LD_list$LD,
                                  locus_dir = locus_dir,
                                  zoom = "4x"
                                  ## These args aren't working atm
                                  # nott_epigenome = TRUE,
                                  # nott_regulatory_rects = TRUE,
                                  # nott_show_placseq = TRUE
                                  )

```




## Run full fine-mapping pipeline   

*UNDER CONSTRUCTION* 

```{r Run fine-mapping pipeline, eval=FALSE}
# results <- echolocatoR::finemap_loci(
#  fullSS_path = mss_out$sumstats,
#  top_SNPs = top_SNPs,
#  loci = top_SNPs$Locus[1],
#  dataset_name = "BD_PGC2021",
#  fullSS_genome_build = "hg19",
#  bp_distance = 250000,
#  munged = TRUE,
#  results_dir = "~/Downloads/BD_finemapping")
```

<hr>

# Session info  

<details>

```{r Session Info, attr.output='style="max-height: 200px;"'}
utils::sessionInfo()
```

</details>

<br>

