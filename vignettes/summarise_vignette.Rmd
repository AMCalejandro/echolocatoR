---
title: "Summarise vignette"
author: "Brian M. Schilder"
date: "Most recent update:<br> `r Sys.Date()`"
output: 
  rmarkdown::html_document: 
    theme: spacelab
    highlight: zenburn 
    code_folding: show 
    toc: true 
    toc_float: true
    smooth_scroll: true
    number_sections: false 
    self_contained: true
editor_options: 
  chunk_output_type: inline
vignette: >
  %\VignetteIndexEntry{summarise_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = T, message = F, error = T}
root.dir <- tempdir()
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  root.dir = root.dir, 
  fig.height = 12,
  fig.width = 10
)  
knitr::opts_knit$set(
  root.dir = root.dir
  )
library(echolocatoR) 
results_dir <- file.path(root.dir,"results")
```


```{r setup}
library(echolocatoR)
```


# Download data  

* Many fine-mapping results can be found on the [echolocatoR Fine-mapping Portal](https://rajlab.shinyapps.io/Fine_Mapping_Shiny).  
* We will download some of those files here using some built-in APIs.  

```{r Download data} 
local_files <- GITHUB.portal_query(dataset_types="GWAS", 
                                   phenotypes = c("parkinson"),
                                   file_types = "multi_finemap",
                                   LD_panels=c("UKB"))

remote_files <- GITHUB.list_files(creator="RajLabMSSM",
                                  repo="Fine_Mapping_Shiny",
                                  query="*Nalls23andMe_2019.*UKB.multi_finemap.csv.gz") 

local_files <- GITHUB.download_files(filelist = remote_files,
                                     download_dir = results_dir,
                                     overwrite = F) 
```

# Merge `echolocatoR` results  

Gather all of the fine-mapping results generated by `finemap_loci()` previously.  

```{r merge_finemapping_results()}
merged_DT <- merge_finemapping_results(minimum_support=0,
                                       include_leadSNPs=T,
                                       dataset = file.path(results_dir,
                                                           "GWAS/Nalls23andMe_2019"),  
                                       from_storage=T,
                                       consensus_threshold = 2,
                                       top_CS_only = T,
                                       haploreg_annotation=F,
                                       biomart_annotation=F, 
                                       verbose = F) 

# Remove some loci you don't want to include
no_no_loci <- c("HLA-DRB5","MAPT","ATG14","SP1","LMNB1","ATP6V0A1", 
                # Tau region 
                "RETREG3","UBTF","FAM171A2","MAP3K14","CRHR1","MAPT-AS1","KANSL1","NSF","WNT3")
merged_DT <- subset(merged_DT, !(Locus %in% no_no_loci))

results_report(merged_DT)
```

# Summarise

## `SUMMARISE.get_SNPgroup_counts()`

Get the number of SNPs for each SNP group per locus.  
It also prints the mean number of SNPs for each SNP group across all loci.  
**NOTE**: You will need to make sure to set `merge_finemapping_results(minimum_support=1)`
in the above step to get accurate counts for all SNP groups.  

```{r SUMMARISE.get_SNPgroup_counts()}
snp_groups <- SUMMARISE.get_SNPgroup_counts(merged_DT=merged_DT)   
createDT(snp_groups)
```

## `SUMMARISE.get_CS_counts()` 

County the number of tool-specific and UCS Credible Set SNPs per locus.  

```{r SUMMARISE.get_CS_counts()}
UCS_counts <- SUMMARISE.get_CS_counts(merged_DT = merged_DT)
print(UCS_counts)
```


# Plot  

- The following functions each return a list containing both the `...$plot` and the `...$data`
used to make the plot.  
- Where available, `snp_filter` allows user to use any filtering argument (supplied as a string)
to subset the data they want to use in the plot/data.  

## `SUMMARISE.CS_bin_plot()`  

Plot the number of number that had Credible Sets of a certain size (per tool).  

```{r SUMMARISE.CS_bin_plot()}
bin_plot <- SUMMARISE.CS_bin_plot(merged_DT = merged_DT, 
                                  show_plot = T) 
createDT(bin_plot$data)
```

## `SUMMARISE.coloc_nominated_eGenes()`  

If you ran colocalization tests with `echolocatoR` (via `catalogueR`) you can use those results to 
come up with a top QTL nominated gene for each locus (potentially implicating that gene in your phenotype).  

### Download COLOC results from [echolocatoR Fine-mapping Portal](https://rajlab.shinyapps.io/Fine_Mapping_Shiny).    

```{r}
remote_coloc <- "https://github.com/RajLabMSSM/Fine_Mapping_Shiny/raw/master/www/data/GWAS/Nalls23andMe_2019/_genome_wide/COLOC/coloc.eQTL_Catalogue_ALL.csv.gz"
local_coloc <- gsub("https://github.com/RajLabMSSM/Fine_Mapping_Shiny/raw/master/www/data",
                    results_dir,
                    remote_coloc)
if(!file.exists(local_coloc)){
  dir.create(dirname(local_coloc), showWarnings = F, recursive = T)
  download.file(remote_coloc, destfile = local_coloc)
} 
```


```{r SUMMARISE.coloc_nominated_eGenes(} 

gg_egene <- SUMMARISE.coloc_nominated_eGenes(coloc_results = local_coloc,
                                             merged_DT = merged_DT,
                                             PP_threshold = .8,
                                             fill_var = NULL,
                                             text_size = 2.5,
                                             y_lab = "Locus",
                                             x_lab = NULL,
                                             label_yaxis = T, 
                                             show_plot = T)
createDT(gg_egene$data)
```

## `SUMMARISE.CS_counts_plot()`  

An extension of `SUMMARISE.get_CS_counts()` that plots these results.  

```{r SUMMARISE.CS_counts_plot()}
gg_CS <- SUMMARISE.CS_counts_plot(merged_DT = merged_DT, 
                                  show_numbers=T,
                                  label_yaxis=T, 
                                  ylabel=NULL, 
                                  show_plot = T)
createDT(gg_CS$data)
```


## `ANNOTATE.plot_missense()`  

Query *biomart* for SNP-level annotations, and then return only those that contain missense mutations.  

```{r}
# Run this in case you don't want to wait to ANNOTATE.plot_missense() to finish querying.
gg_missense <- list(plot=patchwork::plot_spacer())
```

```{r ANNOTATE.plot_missense(), eval=F}
gg_missense <- ANNOTATE.plot_missense(merged_DT = merged_DT, 
                                      snp_filter="Support>0", 
                                      label_yaxis = T,
                                      show_plot = T)  
createDT(gg_missense$data)
```


## `SUMMARISE.peak_overlap_plot()`  

Plot the overlap between some SNP group and cell-type-specific
epigenomic peaks / interactome anchors.  

```{r SUMMARISE.peak_overlap_plot()}
gg_peaks <- SUMMARISE.peak_overlap_plot(merged_DT, 
                                        snp_filter="Consensus_SNP==T",
                                        include.NOTT_2019_peaks=T,
                                        include.NOTT_2019_enhancers_promoters=T,
                                        include.NOTT_2019_PLACseq=T,
                                        include.CORCES_2020_scATACpeaks=T,
                                        include.CORCES_2020_Cicero_coaccess=T,
                                        include.CORCES_2020_bulkATACpeaks=T,
                                        include.CORCES_2020_HiChIP_FitHiChIP_coaccess=T,
                                        include.CORCES_2020_gene_annotations=T,
                                        plot_celltype_specificity=F,
                                        facets_formula=". ~ Cell_type",
                                        show_plot=T,  
                                        label_yaxis=T, 
                                        x_strip_angle = 90,
                                        drop_empty_cols = T,
                                        fill_title="Consensus SNPs\nin epigenomic peaks",
                                        save_path="~/Desktop/peak_plot.consensus.png",
                                        verbose=T)  
createDT(gg_peaks$data)
```

## Multi-plot  

Now for the grand finale, put them all together by calling a single function,`super_summary_plot()`!  
 

```{r super_summary_plot()}

super_plot <- super_summary_plot(merged_DT = merged_DT,
                                  snp_filter="Consensus_SNP==T",
                                  coloc_results=local_coloc,
                                  plot_missense=F,
                                  show_plot=T, 
                                  
                                  save_plot=file.path(results_dir,
                                                      "GWAS/Nalls23andMe_2019/_genome_wide",
                                                      "PD_summary.studies.png"),
                                  height=15,
                                  width=12,
                                  dpi=500)
```


## Manual multi-plot 

Altnernatively, you can gain more customizability by merging your plots together manually with `patchwork`.  

Make sure to set `label_yaxis=F` for some of the plots to avoid redundancy and save space. 

```{r Multi-plot, eval=F} 
library(patchwork)

# Merge
row1 <- (patchwork::plot_spacer() + 
           bin_plot$plot ) +patchwork::plot_layout(widths = c(.4,.6))
row2 <- (gg_egene$plot + 
           gg_CS$plot + 
           gg_missense$plot +
           gg_peaks$plot   
           ) + patchwork::plot_layout(widths = c(.125,.3,.05,1))

gg_merged <- (row1  / row2)  + patchwork::plot_layout(heights = c(.15,1),ncol = 1) 
print(gg_merged)

```
 
# Session info 

<details>

```{r Session Info, attr.output='style="max-height: 200px;"'}
sessioninfo::session_info()
```

</details>

